/*
* 3220162 Πετρουλάκης Ιωσήφ 
* 3220202 Τομαράς Νικόλαος
* 3210134 Μπλέτσης Αλέξανδρος
* 3180215 Μεταξάς Κωνσταντίνος
*/


Package minipython;

Helpers
	digit = ['0' .. '9'];
	letter = ['a' .. 'z']|['A' .. 'Z']; 
	cr = 13; 
	lf = 10;
	space = 32;
	dquote = 34;
	squote = 39;
	all = [0..127]; 
	eol = lf | cr | cr lf ;
	not_eol = [all - [cr + lf]]; 
	dot = '.';
	pound = 35;
	underscore = 95;

Tokens
	dott = dot;
	tab = 9;
	plus = '+';
	minus = '-';
	mult = '*';
	dmult = '**';
	div = '/';
	assign = '=';
	exclam = '!';
	percen = '%';
	minus_assign = '-=';
	div_assign = '/=';
	dict = 'dict';
	def = 'def';
	l_par = '(';
	r_par = ')';
	l_br = '[';
	r_br = ']';
	comma = ',';
	qmark = '?';
	gqmark = ';';
	if = 'if';
	elif = 'elif';
	else = 'else';
	while = 'while';
	for = 'for';
	in = 'in';
	print = 'print';
	return = 'return';
	assert = 'assert';
	len = 'len';
	ascii = 'ascii';
	import = 'import';
	as = 'as';
	from = 'from';
	max = 'max';
	min = 'min';
	less = '<';
	great = '>';
	eq = '==';
	lesseq =  '<=';
	greateq = '>=';
	noteq = '!=';
	true = 'true';
	semi = ':';
	false = 'false';
	and = 'and';
	or = 'or';
	not = 'not';
	blank = space | eol;
	none = 'None';
	line_comment = pound not_eol* eol; 
	number = digit+ | (digit+ dot digit+);
	id = (letter | underscore) (letter | digit | underscore)*;
	string = (dquote not_eol* dquote) | (squote not_eol* squote);
	eof = eol;

Ignored Tokens
	blank, line_comment;



Productions

	p_goal = {goal_syntax} p_line* eof;

	p_line = {line_syntax} p_function | p_statement;

	p_function = {def_syntax} def id l_par p_argument? r_par semi p_statement;

	p_argument = {argument_syntax} id p_assign_value? 
		| {argument_comma_argument_syntax} p_comma_assign_value*;

	p_assign_value = {assign_value_syntax} assign p_value;

	p_comma_assign_value = {comma_assign_value_syntax} comma id p_assign_value?;

	p_statement = {if_syntax} tab* if p_comparison semi p_statement
		| {while_syntax} tab* while p_comparison semi p_statement
		| {for_syntax} tab* for [for_id]:id in [in_id]:id semi p_statement
		| {return_syntax} tab* return p_expression
		| {print_syntax} tab* print p_expression p_comma_expression*
		| {assign_op_syntax} tab* id p_assign_operators p_expression
		| {assign_array_syntax} tab* id l_br [brackets_expression]:p_expression r_br assign [assign_expression]:p_expression
		| {assert_syntax} tab* assert p_expression p_comma_expression?
		| {function_call_syntax} tab* p_function_call
		| {import_syntax} tab* p_import;

	p_comma_expression = {comma_expression} comma p_expression;

	p_assign_operators = {op_assign} assign 
			| {op_minus_assign} minus_assign 
			| {op_div_assign} div_assign;
